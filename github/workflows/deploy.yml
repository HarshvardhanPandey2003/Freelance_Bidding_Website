name: Deploy to AKS

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  RESOURCE_GROUP: hvp-aks
  CLUSTER_NAME: freelance-aks
  KEY_VAULT_NAME: freelance-app-kv-2025

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Azure Login
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ vars.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3

    - name: Get AKS credentials
      run: |
        az aks get-credentials --resource-group ${{ env.RESOURCE_GROUP }} --name ${{ env.CLUSTER_NAME }}

    - name: Get Azure Identity Information
      id: get-identity
      run: |
        SUBSCRIPTION_ID=$(az account show --query id -o tsv)
        NODE_RG=$(az aks show --resource-group ${{ env.RESOURCE_GROUP }} --name ${{ env.CLUSTER_NAME }} --query nodeResourceGroup -o tsv)
        TENANT_ID=$(az account show --query tenantId -o tsv)
        SECRETS_PROVIDER_CLIENT_ID=$(az identity list --resource-group $NODE_RG --query "[?contains(name, 'azurekeyvaultsecretsprovider')].clientId" -o tsv)
        
        echo "tenant-id=$TENANT_ID" >> $GITHUB_OUTPUT
        echo "client-id=$SECRETS_PROVIDER_CLIENT_ID" >> $GITHUB_OUTPUT
        echo "subscription-id=$SUBSCRIPTION_ID" >> $GITHUB_OUTPUT

    - name: Update Secret Provider Class
      run: |
        # Update secret-provider.yaml with actual values
        sed -i "s/userAssignedIdentityID: .*/userAssignedIdentityID: \"${{ steps.get-identity.outputs.client-id }}\"/" k8s-manifests/secrets/secret-provider.yaml
        sed -i "s/tenantId: .*/tenantId: \"${{ steps.get-identity.outputs.tenant-id }}\"/" k8s-manifests/secrets/secret-provider.yaml

    - name: Deploy ConfigMaps and Secrets
      run: |
        kubectl apply -f k8s-manifests/configmaps/app-config.yaml
        kubectl apply -f k8s-manifests/secrets/secret-provider.yaml
        kubectl apply -f k8s-manifests/secrets/service-account.yaml
        
        # Verify deployment
        kubectl get configmap app-config
        kubectl get secretproviderclass app-secrets-provider

    - name: Deploy Applications
      run: |
        kubectl apply -f k8s-manifests/deployments/redis.yaml
        kubectl apply -f k8s-manifests/deployments/backend.yaml
        kubectl apply -f k8s-manifests/deployments/frontend.yaml

    - name: Wait for LoadBalancer IP
      run: |
        echo "Waiting for frontend service to get external IP..."
        kubectl wait --for=condition=Ready pod -l app=frontend --timeout=300s
        
        # Wait for external IP (with timeout) - CORRECTED with [0]
        timeout 300s bash -c 'until kubectl get service frontend-service -o jsonpath="{.status.loadBalancer.ingress.ip}" | grep -E "^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$"; do sleep 10; done'

    - name: Update ConfigMap with External IP
      run: |
        # CORRECTED - Added  for array indexing
        FRONTEND_IP=$(kubectl get service frontend-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        echo "Frontend IP: $FRONTEND_IP"
        
        # Patch all environment variables
        kubectl patch configmap app-config --type merge -p "{\"data\":{\"VITE_API_URL\":\"http://$FRONTEND_IP\"}}"
        kubectl patch configmap app-config --type merge -p "{\"data\":{\"REACT_APP_API_BASE_URL\":\"http://$FRONTEND_IP/api\"}}"
        kubectl patch configmap app-config --type merge -p "{\"data\":{\"FRONTEND_URL\":\"http://$FRONTEND_IP\"}}"
        kubectl patch configmap app-config --type merge -p "{\"data\":{\"BACKEND_API_URL\":\"http://backend-service:5000\"}}"
        kubectl patch configmap app-config --type merge -p "{\"data\":{\"REDIS_URI\":\"redis://redis-service:6379\"}}"
        kubectl patch configmap app-config --type merge -p "{\"data\":{\"NODE_ENV\":\"production\"}}"
        kubectl patch configmap app-config --type merge -p "{\"data\":{\"JWT_EXPIRES_IN\":\"7d\"}}"

    - name: Restart Deployments
      run: |
        kubectl rollout restart deployment/frontend
        kubectl rollout restart deployment/backend  
        
        # Wait for rollouts to complete
        kubectl rollout status deployment/frontend --timeout=300s
        kubectl rollout status deployment/backend --timeout=300s

    - name: Verify Deployment
      run: |
        echo "=== Deployment Status ==="
        kubectl get deployments
        kubectl get pods
        kubectl get services
        
        # CORRECTED - Added [0] for array indexing
        FRONTEND_IP=$(kubectl get service frontend-service -o jsonpath='{.status.loadBalancer.ingress.ip}')
        echo "ðŸš€ Application deployed successfully!"
        echo "Frontend URL: http://$FRONTEND_IP"

    - name: Output Application URL
      run: |
        FRONTEND_IP=$(kubectl get service frontend-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        echo "::notice title=Deployment Success::Application is available at http://$FRONTEND_IP"
