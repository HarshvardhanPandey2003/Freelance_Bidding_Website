name: Deploy to AKS

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  RESOURCE_GROUP: ${{ vars.RESOURCE_GROUP || 'hvp-aks' }}
  CLUSTER_NAME: ${{ vars.CLUSTER_NAME || 'freelance-aks' }}
  KEY_VAULT_NAME: ${{ vars.KEY_VAULT_NAME || 'freelance-app-kv-2025' }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Azure Login
      uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ vars.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3

    - name: Get AKS credentials
      run: |
        az aks get-credentials \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --name ${{ env.CLUSTER_NAME }} \
          --overwrite-existing

    - name: Get Azure Identity Information
      id: get-identity
      run: |
        echo "ğŸ” Retrieving Azure identity information..."
        
        SUBSCRIPTION_ID=$(az account show --query id -o tsv)
        NODE_RG=$(az aks show \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --name ${{ env.CLUSTER_NAME }} \
          --query nodeResourceGroup -o tsv)
        TENANT_ID=$(az account show --query tenantId -o tsv)
        
        # Get the secrets provider identity with better error handling
        SECRETS_PROVIDER_CLIENT_ID=$(az identity list \
          --resource-group $NODE_RG \
          --query "[?contains(name, 'azurekeyvaultsecretsprovider')].clientId" \
          -o tsv)
        
        if [ -z "$SECRETS_PROVIDER_CLIENT_ID" ]; then
          echo "âŒ Error: Could not find azurekeyvaultsecretsprovider identity"
          echo "Available identities:"
          az identity list --resource-group $NODE_RG --query "[].{Name:name, ClientId:clientId}" -o table
          exit 1
        fi
        
        # Set outputs for other steps to use
        echo "tenant-id=$TENANT_ID" >> $GITHUB_OUTPUT
        echo "client-id=$SECRETS_PROVIDER_CLIENT_ID" >> $GITHUB_OUTPUT
        echo "subscription-id=$SUBSCRIPTION_ID" >> $GITHUB_OUTPUT
        echo "node-rg=$NODE_RG" >> $GITHUB_OUTPUT
        
        echo "âœ… Retrieved identity information:"
        echo "  â€¢ Tenant ID: $TENANT_ID"
        echo "  â€¢ Client ID: $SECRETS_PROVIDER_CLIENT_ID"
        echo "  â€¢ Node RG: $NODE_RG"

    - name: Update Secret Provider Class
      run: |
        echo "ğŸ”§ Updating secret-provider.yaml with identity information..."
        
        # Update secret-provider.yaml with actual values
        sed -i "s/userAssignedIdentityID: .*/userAssignedIdentityID: \"${{ steps.get-identity.outputs.client-id }}\"/" k8s-manifests/secrets/secret-provider.yaml
        sed -i "s/tenantId: .*/tenantId: \"${{ steps.get-identity.outputs.tenant-id }}\"/" k8s-manifests/secrets/secret-provider.yaml
        
        echo "âœ… Updated secret-provider.yaml"
        echo "  â€¢ User Assigned Identity ID: ${{ steps.get-identity.outputs.client-id }}"
        echo "  â€¢ Tenant ID: ${{ steps.get-identity.outputs.tenant-id }}"

    - name: Deploy ConfigMaps and Secrets
      run: |
        echo "ğŸ“¦ Deploying ConfigMaps and Secrets..."
        
        kubectl apply -f k8s-manifests/configmaps/app-config.yaml
        kubectl apply -f k8s-manifests/secrets/secret-provider.yaml
        kubectl apply -f k8s-manifests/secrets/service-account.yaml
        
        # Wait for secret provider to be ready
        echo "â³ Waiting for secrets store CSI driver to be ready..."
        kubectl wait --for=condition=Ready pod \
          -l app=secrets-store-csi-driver \
          --timeout=120s \
          -n kube-system || echo "âš ï¸ CSI driver pods may still be starting"
        
        echo "âœ… Deployed ConfigMaps and Secrets"

    - name: Deploy Applications
      run: |
        echo "ğŸš€ Deploying applications..."
        
        kubectl apply -f k8s-manifests/deployments/redis.yaml
        kubectl apply -f k8s-manifests/deployments/backend.yaml
        kubectl apply -f k8s-manifests/deployments/frontend.yaml
        
        echo "âœ… Application manifests deployed"

    - name: Wait for Deployments
      run: |
        echo "â³ Waiting for deployments to be ready..."
        
        # Wait for deployments to be available
        kubectl wait --for=condition=available deployment/redis --timeout=300s
        kubectl wait --for=condition=available deployment/backend --timeout=300s
        kubectl wait --for=condition=available deployment/frontend --timeout=300s
        
        echo "âœ… All deployments are ready"

    - name: Get LoadBalancer IP
      id: get-ip
      run: |
        echo "ğŸŒ Waiting for LoadBalancer to assign external IP..."
        
        FRONTEND_IP=""
        for i in {1..30}; do
          FRONTEND_IP=$(kubectl get service frontend-service \
            -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
          
          if [[ $FRONTEND_IP =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "âœ… External IP assigned: $FRONTEND_IP"
            break
          fi
          
          echo "â³ Attempt $i/30: Waiting for external IP... (current: '$FRONTEND_IP')"
          sleep 20
        done
        
        if [[ ! $FRONTEND_IP =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          echo "âŒ Failed to get external IP after 10 minutes"
          echo "Service status:"
          kubectl get service frontend-service -o wide
          kubectl describe service frontend-service
          exit 1
        fi
        
        # Set output for other steps to use
        echo "frontend-ip=$FRONTEND_IP" >> $GITHUB_OUTPUT
        echo "api-url=http://$FRONTEND_IP/api" >> $GITHUB_OUTPUT
        echo "frontend-url=http://$FRONTEND_IP" >> $GITHUB_OUTPUT

    - name: Update ConfigMap with External IP
      run: |
        echo "ğŸ”„ Updating ConfigMap with LoadBalancer IP..."
        
        # Use the output from get-ip step (no repeated kubectl calls)
        FRONTEND_IP="${{ steps.get-ip.outputs.frontend-ip }}"
        API_URL="${{ steps.get-ip.outputs.api-url }}"
        FRONTEND_URL="${{ steps.get-ip.outputs.frontend-url }}"
        
        echo "  â€¢ Frontend IP: $FRONTEND_IP"
        echo "  â€¢ API URL: $API_URL"
        echo "  â€¢ Frontend URL: $FRONTEND_URL"
        
        # Create patch file for cleaner configuration updates
        cat > /tmp/configmap-patch.yaml << EOF
        data:
          VITE_API_URL: "$API_URL"
          REACT_APP_API_BASE_URL: "$API_URL"
          FRONTEND_URL: "$FRONTEND_URL"
          BACKEND_API_URL: "http://backend-service:5000"
          REDIS_URI: "redis://redis-service:6379"
          NODE_ENV: "production"
          JWT_EXPIRES_IN: "7d"
        EOF
        
        # Apply the patch
        kubectl patch configmap app-config --patch-file /tmp/configmap-patch.yaml
        rm /tmp/configmap-patch.yaml
        
        echo "âœ… ConfigMap updated with external IP configuration"

    - name: Restart Deployments
      run: |
        echo "ğŸ”„ Restarting deployments to pick up new configuration..."
        
        # Restart deployments to pick up new ConfigMap values
        kubectl rollout restart deployment/frontend
        kubectl rollout restart deployment/backend
        
        echo "â³ Waiting for rollouts to complete..."
        kubectl rollout status deployment/frontend --timeout=300s
        kubectl rollout status deployment/backend --timeout=300s
        
        echo "âœ… Deployments restarted successfully"

    - name: Verify Deployment Status
      run: |
        echo "ğŸ“Š === Final Deployment Status ==="
        echo ""
        echo "ğŸ—ï¸  Deployments:"
        kubectl get deployments -o wide
        echo ""
        echo "ğŸ“¦ Pods:"
        kubectl get pods -o wide
        echo ""
        echo "ğŸŒ Services:"
        kubectl get services -o wide
        echo ""
        echo "ğŸ” Secrets:"
        kubectl get secretproviderclass -o wide

    - name: Health Check
      run: |
        echo "ğŸ¥ Performing application health check..."
        
        # Use the stored IP from get-ip step output
        FRONTEND_IP="${{ steps.get-ip.outputs.frontend-ip }}"
        
        # Wait for application to be fully ready
        echo "â³ Waiting for application to be fully ready..."
        sleep 45
        
        # Test frontend endpoint
        echo "ğŸ” Testing frontend endpoint..."
        if timeout 30 curl -sS -f "http://$FRONTEND_IP" > /dev/null 2>&1; then
          echo "âœ… Frontend is responding correctly"
        else
          echo "âš ï¸  Frontend health check failed (app may still be starting)"
          echo "This is often normal for initial deployments"
        fi
        
        # Test if backend service is accessible internally
        echo "ğŸ” Checking backend service availability..."
        kubectl run test-curl --image=curlimages/curl:latest --rm -i --restart=Never \
          --command -- curl -sS -f "http://backend-service:5000/health" || \
          echo "âš ï¸  Backend health endpoint not available (may not be implemented)"

    - name: Output Deployment Results
      run: |
        echo "ğŸ‰ === DEPLOYMENT COMPLETED SUCCESSFULLY ==="
        echo ""
        echo "ğŸ“± Application URLs:"
        echo "  â€¢ Frontend: ${{ steps.get-ip.outputs.frontend-url }}"
        echo "  â€¢ Backend API: ${{ steps.get-ip.outputs.api-url }}"
        echo ""
        echo "ğŸ”§ Infrastructure Details:"
        echo "  â€¢ Resource Group: ${{ env.RESOURCE_GROUP }}"
        echo "  â€¢ AKS Cluster: ${{ env.CLUSTER_NAME }}"
        echo "  â€¢ Key Vault: ${{ env.KEY_VAULT_NAME }}"
        echo "  â€¢ LoadBalancer IP: ${{ steps.get-ip.outputs.frontend-ip }}"
        echo ""
        echo "::notice title=ğŸš€ Deployment Success::Application is live at ${{ steps.get-ip.outputs.frontend-url }}"
        echo "::notice title=ğŸ”— API Endpoint::Backend API available at ${{ steps.get-ip.outputs.api-url }}"
