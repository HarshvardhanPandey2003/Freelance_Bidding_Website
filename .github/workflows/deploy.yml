name: GitOps Build and Deploy

on:
  push:
    branches: [main, prod, gitops]
  workflow_dispatch:

env:
  RESOURCE_GROUP: ${{ vars.RESOURCE_GROUP || 'hvp-aks' }}
  CLUSTER_NAME: ${{ vars.CLUSTER_NAME || 'freelance-aks' }}
  KEY_VAULT_NAME: ${{ vars.KEY_VAULT_NAME || 'freelance-app-kv-2025' }}

jobs:
  build-and-gitops-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ vars.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Azure Login
      uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3

    - name: Get AKS credentials
      run: |
        az aks get-credentials \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --name ${{ env.CLUSTER_NAME }} \
          --overwrite-existing

    # BUILD PHASE
    - name: Build and Push Backend
      uses: docker/build-push-action@v5
      with:
        context: ./backend
        push: true
        tags: ${{ vars.DOCKERHUB_USERNAME }}/freelance-backend:${{ github.sha }}

    - name: Build and Push Frontend
      uses: docker/build-push-action@v5
      with:
        context: ./frontend
        push: true
        tags: ${{ vars.DOCKERHUB_USERNAME }}/freelance-frontend:${{ github.sha }}

    # GET AZURE IDENTITY
    - name: Get Azure Identity Information
      id: get-identity
      run: |
        echo "ğŸ” Retrieving Azure identity information..."
        
        NODE_RG=$(az aks show \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --name ${{ env.CLUSTER_NAME }} \
          --query nodeResourceGroup -o tsv)
        TENANT_ID=$(az account show --query tenantId -o tsv)
        
        SECRETS_PROVIDER_CLIENT_ID=$(az identity list \
          --resource-group $NODE_RG \
          --query "[?contains(name, 'azurekeyvaultsecretsprovider')].clientId" \
          -o tsv)
        
        echo "tenant-id=$TENANT_ID" >> $GITHUB_OUTPUT
        echo "client-id=$SECRETS_PROVIDER_CLIENT_ID" >> $GITHUB_OUTPUT
        
        echo "âœ… Retrieved identity information:"
        echo "  â€¢ Tenant ID: $TENANT_ID"
        echo "  â€¢ Client ID: $SECRETS_PROVIDER_CLIENT_ID"

    # UPDATE MANIFESTS FOR GITOPS
    - name: Update Kubernetes Manifests
      run: |
        echo "ğŸ”„ Updating manifests for GitOps..."
        
        # Update image tags
        sed -i "s|image: .*/freelance-backend:.*|image: ${{ vars.DOCKERHUB_USERNAME }}/freelance-backend:${{ github.sha }}|" k8s-manifests/deployments/backend.yaml
        sed -i "s|image: .*/freelance-frontend:.*|image: ${{ vars.DOCKERHUB_USERNAME }}/freelance-frontend:${{ github.sha }}|" k8s-manifests/deployments/frontend.yaml
        
        # Update Azure Key Vault identity (using your original method)
        sed -i "s/userAssignedIdentityID: .*/userAssignedIdentityID: \"${{ steps.get-identity.outputs.client-id }}\"/" k8s-manifests/secrets/secret-provider.yaml
        sed -i "s/tenantId: .*/tenantId: \"${{ steps.get-identity.outputs.tenant-id }}\"/" k8s-manifests/secrets/secret-provider.yaml
        
        echo "âœ… Updated manifests:"
        echo "  â€¢ Backend image: ${{ vars.DOCKERHUB_USERNAME }}/freelance-backend:${{ github.sha }}"
        echo "  â€¢ Frontend image: ${{ vars.DOCKERHUB_USERNAME }}/freelance-frontend:${{ github.sha }}"

    # COMMIT TO TRIGGER ARGOCD
    - name: Commit Manifest Changes
      run: |
      # This is used for getting the info of the user in git commiting the changes
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        git add k8s-manifests/
        
        if git diff --staged --quiet; then
          echo "ğŸ“ No manifest changes to commit"
        else
          git commit -m "ğŸš€ GitOps: Update images to ${{ github.sha }}" 
          
          # This SHA creates unique id which means different verisons for all the images 
          git push
          echo "âœ… Manifests committed - ArgoCD will sync!"
        fi

    # WAIT FOR ARGOCD TO DEPLOY - OPTIMIZED VERSION
    - name: Wait for ArgoCD Sync and Deployment
      run: |
        echo "â³ Waiting for ArgoCD to detect and sync changes..."
        
        # Wait for ArgoCD to detect changes (reduced from 120s)
        sleep 30
        
        # Check ArgoCD sync status
        echo "ğŸ” Checking ArgoCD application status..."
        for i in {1..12}; do  # 2 minutes max
          SYNC_STATUS=$(kubectl get application freelance-app -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
          HEALTH_STATUS=$(kubectl get application freelance-app -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")
          
          echo "ğŸ“Š Attempt $i/20: Sync: $SYNC_STATUS, Health: $HEALTH_STATUS"
          
          if [[ "$SYNC_STATUS" == "Synced" && "$HEALTH_STATUS" == "Healthy" ]]; then
            echo "âœ… ArgoCD sync completed successfully!"
            break
          fi
          
          if [[ "$SYNC_STATUS" == "OutOfSync" ]]; then
            echo "ğŸ”„ ArgoCD detected changes, syncing..."
          fi
          
          sleep 15
        done
        
        # Verify deployments are ready (reduced timeouts)
        echo "ğŸ” Verifying deployment readiness..."
        kubectl wait --for=condition=available deployment/redis --timeout=90s
        kubectl wait --for=condition=available deployment/backend --timeout=90s  
        kubectl wait --for=condition=available deployment/frontend --timeout=90s
        
        echo "âœ… All deployments are ready"

    # DYNAMIC LOADBALANCER IP UPDATE (Your original working method)
    - name: Get LoadBalancer IP and Update ConfigMap
      id: get-ip
      run: |
        echo "ğŸŒ Getting LoadBalancer IP for dynamic configuration..."
        
        # Wait for LoadBalancer IP (exactly like your original)
        FRONTEND_IP=""
        for i in {1..12}; do  # 2 minutes
          FRONTEND_IP=$(kubectl get ingress app-ingress \
            -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
          
          if [[ $FRONTEND_IP =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "âœ… External IP assigned: $FRONTEND_IP"
            break
          fi
          
          echo "â³ Attempt $i/12: Waiting for external IP... (current: '$FRONTEND_IP')"
          sleep 10
        done
        
        if [[ ! $FRONTEND_IP =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          echo "âŒ Failed to get external IP after 2 minutes"
          echo "Ingress status:"
          kubectl get ingress app-ingress -o wide
          kubectl describe ingress app-ingress
          exit 1
        fi
        
        # Set outputs (same as your original)
        API_URL="http://$FRONTEND_IP/api"
        FRONTEND_URL="http://$FRONTEND_IP"
        
        echo "frontend-ip=$FRONTEND_IP" >> $GITHUB_OUTPUT
        echo "api-url=$API_URL" >> $GITHUB_OUTPUT
        echo "frontend-url=$FRONTEND_URL" >> $GITHUB_OUTPUT
        
        echo "  â€¢ Frontend IP: $FRONTEND_IP"
        echo "  â€¢ API URL: $API_URL"
        echo "  â€¢ Frontend URL: $FRONTEND_URL"
        
        # Update ConfigMap using your ORIGINAL working method
        echo "ğŸ”„ Updating ConfigMap with LoadBalancer IP..."
        
        cat > /tmp/configmap-patch.yaml << EOF
        data:
          FRONTEND_URL: "$FRONTEND_URL"
        EOF
        
        # Apply the patch using --patch-file (your working method)
        kubectl patch configmap app-config --patch-file /tmp/configmap-patch.yaml
        rm /tmp/configmap-patch.yaml
        
        echo "âœ… ConfigMap updated with external IP configuration"

    # RESTART DEPLOYMENTS (Your original method)
    - name: Restart Deployments
      run: |
        echo "ğŸ”„ Restarting deployments to pick up new configuration..."
        
        # Restart deployments to pick up new ConfigMap values
        kubectl rollout restart deployment/frontend
        kubectl rollout restart deployment/backend
        
        echo "â³ Waiting for rollouts to complete..."
        kubectl rollout status deployment/frontend --timeout=100s
        kubectl rollout status deployment/backend --timeout=100s
        
        echo "âœ… Deployments restarted successfully"

    # FINAL STATUS AND HEALTH CHECK (Your original methods)
    - name: Verify Deployment Status
      run: |
        echo "ğŸ“Š === Final Deployment Status ==="
        echo ""
        echo "ğŸ—ï¸  Deployments:"
        kubectl get deployments -o wide
        echo ""
        echo "ğŸ“¦ Pods:"
        kubectl get pods -o wide
        echo ""
        echo "ğŸŒ Services:"
        kubectl get services -o wide
        echo ""
        echo "ğŸ”— Ingress:"
        kubectl get ingress -o wide

    - name: Quick Health Verification
      run: |
        echo "ğŸ¥ Quick health verification..."
        FRONTEND_IP="${{ steps.get-ip.outputs.frontend-ip }}"
        
        # Reduced wait time
        sleep 20
        
        # Parallel health checks
        {
          if timeout 15 curl -sS -f "http://$FRONTEND_IP/api/health" >/dev/null 2>&1; then
            echo "âœ… API endpoint healthy"
          else
            echo "âš ï¸ API endpoint check failed"
          fi
        } &
        
        {
          if timeout 15 curl -sS -f "http://$FRONTEND_IP" >/dev/null 2>&1; then
            echo "âœ… Frontend healthy"
          else
            echo "âš ï¸ Frontend check failed"
          fi
        } &
        
        wait
        echo "ğŸ‰ Health checks completed"

    # FINAL OUTPUT (Your original format)
    - name: Output Deployment Results
      run: |
        echo "ğŸ‰ === GITOPS DEPLOYMENT COMPLETED SUCCESSFULLY ==="
        echo ""
        echo "ğŸ“± Application URLs:"
        echo "  â€¢ Frontend: ${{ steps.get-ip.outputs.frontend-url }}"
        echo "  â€¢ Backend API: ${{ steps.get-ip.outputs.api-url }}"
        echo ""
        echo "ğŸ”§ Infrastructure Details:"
        echo "  â€¢ Resource Group: ${{ env.RESOURCE_GROUP }}"
        echo "  â€¢ AKS Cluster: ${{ env.CLUSTER_NAME }}"
        echo "  â€¢ Key Vault: ${{ env.KEY_VAULT_NAME }}"
        echo "  â€¢ LoadBalancer IP: ${{ steps.get-ip.outputs.frontend-ip }}"
        echo ""
        echo "ğŸ¯ GitOps Status: Static manifests managed by ArgoCD"
        echo "ğŸ”„ Dynamic Config: LoadBalancer IP updated via CI/CD"
        echo ""
        echo "::notice title=ğŸš€ GitOps Deploy Success::Application is live at ${{ steps.get-ip.outputs.frontend-url }}"
        echo "::notice title=ğŸ”— API Endpoint::Backend API available at ${{ steps.get-ip.outputs.api-url }}"
